OEP: 4
Title: EnvPlugin Documentation Validation and Custom mkdocstrings Handler
Author: Open World Agents Team
Status: Draft
Type: Standards Track
Requires: 3
Created: 01-Feb-2025
Post-History: 01-Feb-2025

Abstract
========

This OEP introduces a documentation validation system for EnvPlugins and a custom mkdocstrings handler for automatic documentation generation. The primary focus is on providing a `owl env validate-docs` command that can be used as a test utility for plugin quality assurance, with proper exit codes for CI/CD integration. Additionally, a minimal custom mkdocstrings handler enables automatic documentation generation from existing docstrings without manual maintenance.

Motivation
==========

The current OEP-3 plugin system lacks systematic documentation validation and automated documentation generation:

1. **No Documentation Quality Assurance**: There's no standardized way to validate that plugins have adequate documentation, making it difficult to maintain quality standards across the ecosystem
2. **Missing CI/CD Integration**: Plugin contributors need a test command that can validate documentation quality with proper exit codes for automated testing
3. **Manual Documentation Maintenance**: Plugin developers must manually maintain separate documentation files, leading to synchronization issues
4. **Limited mkdocstrings Integration**: While mkdocstrings works well for regular Python packages, it doesn't understand OWA's plugin structure and component organization

These limitations create barriers for both plugin quality assurance and documentation automation in CI/CD pipelines.

Rationale
=========

The design focuses on two key areas: documentation validation for quality assurance and minimal mkdocstrings integration:

**Documentation Validation as Testing**: The `owl env validate-docs` command serves as a test utility that can be integrated into CI/CD pipelines, ensuring consistent documentation quality across all plugins with proper exit codes.

**Minimal mkdocstrings Handler**: A lightweight custom handler that understands OWA's plugin structure, enabling automatic documentation generation without complex infrastructure.

**CI/CD Integration**: Proper stdout/stderr output and exit codes make documentation validation part of the standard testing workflow for plugin contributions.

**Zero-Configuration Approach**: Both validation and documentation generation work out-of-the-box with existing plugin structures, requiring no additional configuration files or metadata.

Specification
=============

## Documentation Validation Command

### `owl env validate-docs` as Test Utility

The primary feature is a validation command that can be used as a test in CI/CD pipelines:

```bash
# Basic validation with quality grades
$ owl env validate-docs
‚úÖ std plugin: 2/2 documented (100%), 2/2 good quality (100%)
‚ö†Ô∏è  example plugin: 7/7 documented (100%), 3/7 good quality (43%)
‚ö†Ô∏è  desktop plugin: 20/25 documented (80%), 12/25 good quality (48%)
‚ùå custom plugin: 1/5 documented (20%), 0/5 good quality (0%)

üìä Overall: 30/39 documented (77%), 17/39 good quality (44%)
‚ö†Ô∏è  WARN: Some plugins below quality thresholds
$ echo $?
1

# Validation for specific plugin
$ owl env validate-docs example
‚ö†Ô∏è  example plugin: 7/7 documented (100%), 3/7 good quality (43%)
‚ö†Ô∏è  WARN: Plugin below good quality threshold (60%)
$ echo $?
1

# Quality-focused validation with custom thresholds
$ owl env validate-docs --min-quality-pass 0.7 --min-quality-fail 0.5
‚úÖ std plugin: 2/2 documented (100%), 2/2 good quality (100%)
‚ö†Ô∏è  example plugin: 7/7 documented (100%), 3/7 good quality (43%)
‚ùå FAIL: Some plugins below quality thresholds (PASS: 80%/70%, FAIL: 60%/50%)
$ echo $?
1

# Strict mode for CI/CD (enforces 90%/70% coverage + 80%/60% quality)
$ owl env validate-docs --strict
‚ùå FAIL: Good quality ratio 44% below threshold (80%)
$ echo $?
1

# Custom coverage thresholds
$ owl env validate-docs --min-coverage-pass 0.9 --min-coverage-fail 0.7
‚ùå FAIL: Documentation coverage 77% below threshold (90%)
$ echo $?
1

# JSON output for tooling integration
$ owl env validate-docs --format json
{
  "overall_coverage": 0.77,
  "overall_quality": 0.44,
  "plugins": {
    "std": {
      "documented": 2, "total": 2, "coverage": 1.0,
      "good_quality": 2, "quality_ratio": 1.0, "status": "pass"
    },
    "example": {
      "documented": 7, "total": 7, "coverage": 1.0,
      "good_quality": 3, "quality_ratio": 0.43, "status": "warning"
    },
    "desktop": {
      "documented": 20, "total": 25, "coverage": 0.8,
      "good_quality": 12, "quality_ratio": 0.48, "status": "warning"
    },
    "custom": {
      "documented": 1, "total": 5, "coverage": 0.2,
      "good_quality": 0, "quality_ratio": 0.0, "status": "fail"
    }
  },
  "exit_code": 1
}
```

### Exit Code Specification

The command follows standard Unix conventions for test utilities:

- **Exit Code 0**: All validations passed
- **Exit Code 1**: Documentation issues found (warnings or failures)
- **Exit Code 2**: Command error (invalid arguments, plugin not found, etc.)

### Validation Criteria

#### Component-Level Quality Grades

**GOOD** ‚úÖ (High quality documentation)
- Has non-empty docstring
- Has examples OR type hints OR comprehensive description (>100 characters)
- Meets basic quality standards

**ACCEPTABLE** üìù (Basic documentation)
- Has non-empty docstring
- Missing examples, type hints, or comprehensive description
- Still counts as "documented" but lower quality

**POOR** ‚ùå (No documentation)
- No docstring or empty docstring
- Component is considered "undocumented"

#### Per-Plugin Quality Thresholds

**PASS** ‚úÖ (Plugin is well-documented)
- ‚â• 80% of components are GOOD or ACCEPTABLE
- ‚â• 60% of components are GOOD (high quality)

**WARN** ‚ö†Ô∏è (Plugin needs improvement)
- 60-79% of components are documented (GOOD or ACCEPTABLE)
- OR < 60% of components are GOOD quality

**FAIL** ‚ùå (Plugin is poorly documented)
- < 60% of components are documented

#### Skip Quality Check Feature

Components can opt out of quality checks using docstring comments:

```python
def legacy_function():
    """Legacy function with minimal docs.

    @skip-quality-check: legacy-code
    """
    pass

class InternalClass:
    """Internal implementation class.

    @skip-quality-check: internal-api
    """
    pass
```

**Valid skip reasons**: `legacy-code`, `internal-api`, `experimental`, `deprecated`, `third-party`

**Note**: Skipped components are excluded from quality calculations entirely.

```python
# Validation rules implementation
class DocumentationValidator:
    def validate_component(self, component) -> ValidationResult:
        issues = []
        
        # Check docstring presence
        if not component.docstring:
            issues.append("Missing docstring")
        
        # Check docstring quality
        if component.docstring and not component.docstring.summary:
            issues.append("Missing summary in docstring")
        
        # Check parameters documentation
        if component.parameters and not component.docstring.parameters:
            issues.append("Parameters not documented")
        
        # Check type hints
        if not component.type_hints:
            issues.append("Missing type hints")
        
        # Check examples
        if not component.docstring.examples:
            issues.append("Missing usage examples")
        
        return ValidationResult(
            component=component.full_name,
            status="pass" if not issues else "fail",
            issues=issues
        )
```

## Custom mkdocstrings Handler

### Minimal Handler Implementation

A lightweight custom mkdocstrings handler that understands OWA plugin structure:

**Implementation Note**: The handler includes graceful degradation when mkdocstrings is not available, ensuring the core functionality remains intact even in minimal environments.

```python
# Custom mkdocstrings handler for EnvPlugin components
from mkdocstrings.handlers.base import BaseHandler
from owa.core.plugin_discovery import get_plugin_discovery

class EnvPluginHandler(BaseHandler):
    """Minimal mkdocstrings handler for OWA EnvPlugin components."""
    
    name = "envplugin"
    domain = "py"
    fallback_theme = "material"
    
    def collect(self, identifier: str, options: dict) -> dict:
        """Collect documentation data for an EnvPlugin component."""
        if "/" in identifier:
            namespace, component = identifier.split("/", 1)
            return self._collect_component(namespace, component)
        else:
            return self._collect_plugin(identifier)
    
    def render(self, data: dict, options: dict) -> str:
        """Render using specialized templates."""
        template_name = "envplugin.html" if data.get("type") == "plugin" else "component.html"
        template = self.env.get_template(template_name)
        return template.render(data=data, options=options)

# Entry point registration
def get_handler(**kwargs) -> EnvPluginHandler:
    return EnvPluginHandler(**kwargs)
```

### Usage in Documentation

The handler enables automatic documentation generation using familiar mkdocstrings syntax:

```markdown
# Plugin overview
::: example
    handler: envplugin

# Individual component
::: example/mouse.click
    handler: envplugin
    options:
      show_signature: true
      show_examples: true
```

### Integration Setup

```toml
# pyproject.toml - Register the custom handler
[project.entry-points."mkdocstrings.handlers"]
envplugin = "owa.core.documentation.mkdocstrings_handler:get_handler"
```

```yaml
# mkdocs.yml - Configure the handler
plugins:
  - mkdocstrings:
      handlers:
        envplugin:
          options:
            show_plugin_metadata: true
            include_source_links: true
```

**Note**: The envplugin handler follows the mkdocstrings custom handler convention and is located in `mkdocstrings_handlers/envplugin.py`. It automatically imports OWA modules when available.

## CI/CD Integration

### Using as Test Command

The validation command integrates seamlessly into testing workflows:

```bash
# In CI/CD pipeline (GitHub Actions, GitLab CI, etc.)
- name: Validate Plugin Documentation
  run: |
    owl env validate-docs --strict --min-coverage 90
    
# In pre-commit hooks
- repo: local
  hooks:
    - id: validate-docs
      name: Validate EnvPlugin Documentation
      entry: owl env validate-docs
      language: system
      pass_filenames: false

# In pytest integration
def test_plugin_documentation():
    """Test that all plugins have adequate documentation."""
    result = subprocess.run(
        ["owl", "env", "validate-docs", "--format", "json"],
        capture_output=True, text=True
    )
    
    data = json.loads(result.stdout)
    assert data["overall_coverage"] >= 0.9, f"Documentation coverage {data['overall_coverage']} below 90%"
    assert result.returncode == 0, "Documentation validation failed"
```

### Repository-wide Application

Apply validation across the entire repository:

```bash
# Validate all existing plugins
$ owl env validate-docs --all --strict
‚úÖ std plugin: 2/2 components documented (100%)
‚úÖ example plugin: 7/7 components documented (100%)  
‚úÖ desktop plugin: 25/25 components documented (100%)
‚ö†Ô∏è  gst plugin: 3/4 components documented (75%)

üìä Overall: 37/41 components documented (90%)
‚úÖ PASS: Documentation coverage meets minimum threshold

# Generate validation report
$ owl env validate-docs --all --format json > docs-validation-report.json

# Check specific documentation quality
$ owl env validate-docs --check-quality --min-examples 1
‚ùå desktop/window.get_active: Missing usage examples
‚ùå gst/screen: Missing parameter documentation
‚ö†Ô∏è  Found 2 quality issues across 4 plugins
```

Implementation
=============

The implementation focuses on two key areas: documentation validation for CI/CD integration and minimal mkdocstrings support.

### Documentation Validation Implementation

```python
# owa/core/cli/docs.py - Enhanced validation command
import sys
import json
from typing import Dict, List, Optional

def validate_docs(
    plugin_namespace: Optional[str] = None,
    strict: bool = False,
    min_coverage: float = 0.9,
    format: str = "text"
) -> int:
    """
    Validate plugin documentation with proper exit codes.
    
    Returns:
        0: All validations passed
        1: Documentation issues found
        2: Command error
    """
    try:
        validator = DocumentationValidator()
        
        if plugin_namespace:
            results = validator.validate_plugin(plugin_namespace)
        else:
            results = validator.validate_all_plugins()
        
        # Calculate overall coverage
        total_components = sum(r.total for r in results.values())
        documented_components = sum(r.documented for r in results.values())
        overall_coverage = documented_components / total_components if total_components > 0 else 0
        
        # Check coverage threshold
        coverage_pass = overall_coverage >= min_coverage
        
        # Output results
        if format == "json":
            output = {
                "overall_coverage": overall_coverage,
                "plugins": {
                    name: {
                        "coverage": r.documented / r.total if r.total > 0 else 0,
                        "documented": r.documented,
                        "total": r.total,
"status": "pass" if r.documented == r.total else "warning" if r.documented >= 0.75 * r.total else "fail"
                    }
                    for name, r in results.items()
                },
                "exit_code": 0 if coverage_pass else 1
            }
            print(json.dumps(output, indent=2))
        else:
            # Text output with emojis
            for name, result in results.items():
                coverage = result.documented / result.total if result.total > 0 else 0
                status = "‚úÖ" if coverage == 1.0 else "‚ö†Ô∏è" if coverage >= 0.75 else "‚ùå"
                print(f"{status} {name} plugin: {result.documented}/{result.total} components documented ({coverage:.0%})")
            
            print(f"\nüìä Overall: {documented_components}/{total_components} components documented ({overall_coverage:.0%})")
            
            if coverage_pass:
                print("‚úÖ PASS: Documentation coverage meets minimum threshold")
            else:
                print(f"‚ùå FAIL: Documentation coverage {overall_coverage:.0%} below minimum {min_coverage:.0%}")
        
        return 0 if coverage_pass else 1
        
    except Exception as e:
        print(f"‚ùå ERROR: {e}", file=sys.stderr)
        return 2
```

### Minimal mkdocstrings Handler

```python
# owa/core/documentation/mkdocstrings_handler.py
from mkdocstrings.handlers.base import BaseHandler
from ..plugin_discovery import get_plugin_discovery

class EnvPluginHandler(BaseHandler):
    """Minimal mkdocstrings handler for OWA EnvPlugin components."""

    name = "envplugin"
    domain = "py"
    fallback_theme = "material"

    def collect(self, identifier: str, options: dict) -> dict:
        """Collect documentation data for an EnvPlugin component."""
        plugin_discovery = get_plugin_discovery()

        if "/" in identifier:
            namespace, component = identifier.split("/", 1)
            return self._collect_component(namespace, component, plugin_discovery)
        else:
            return self._collect_plugin(identifier, plugin_discovery)

    def _collect_plugin(self, namespace: str, plugin_discovery) -> dict:
        """Collect plugin-level documentation."""
        plugin_spec = plugin_discovery.discovered_plugins.get(namespace)
        if not plugin_spec:
            return {"error": f"Plugin '{namespace}' not found"}

        return {
            "type": "plugin",
            "namespace": namespace,
            "version": plugin_spec.version,
            "description": plugin_spec.description,
            "author": plugin_spec.author,
            "components": self._extract_components(plugin_spec)
        }

    def render(self, data: dict, options: dict) -> str:
        """Render using specialized templates."""
        if data.get("error"):
            return f"<div class='error'>Error: {data['error']}</div>"

        template_name = "envplugin.html" if data.get("type") == "plugin" else "component.html"
        template = self.env.get_template(template_name)
        return template.render(data=data, options=options)

def get_handler(**kwargs) -> EnvPluginHandler:
    return EnvPluginHandler(**kwargs)
```

### Entry Point Registration

```toml
# pyproject.toml
[project.entry-points."mkdocstrings.handlers"]
envplugin = "owa.core.documentation.mkdocstrings_handler:get_handler"
```

**Core Components:**
- `owa.core.documentation.validator.DocumentationValidator` - Documentation validation engine
- `owa.core.documentation.mkdocstrings_handler.EnvPluginHandler` - Minimal custom mkdocstrings handler
- `owa.core.cli.docs` - Enhanced CLI commands with validation support

**Validation Features:**
- Exit code compliance for CI/CD integration (0=pass, 1=fail, 2=error)
- JSON output format for tooling integration
- Configurable coverage thresholds and quality checks
- Repository-wide validation support

**mkdocstrings Integration:**
- Lightweight custom handler for OWA plugin structure
- Entry point registration for automatic discovery
- Familiar mkdocstrings syntax and workflow
- Zero-configuration setup for existing plugins

Rejected Ideas
==============

### Complex Documentation Generation System

A comprehensive documentation generation system similar to Sphinx was considered but rejected because:
- Adds significant complexity and maintenance overhead
- Conflicts with the minimal, performant approach requested
- mkdocstrings already provides excellent documentation generation
- Focus should be on validation and minimal integration, not reinventing documentation tools

### Runtime Documentation Validation

Validating documentation at plugin load time was considered but rejected because:
- Would impact the performance benefits of OEP-3's lazy loading
- Unnecessary overhead for users who don't need documentation validation
- Conflicts with the on-demand principle of the plugin system
- Documentation validation should be a development/CI tool, not a runtime feature

### Comprehensive Template System

A full template system with extensive customization options was considered but rejected because:
- Adds complexity without clear benefit for the minimal use case
- mkdocstrings already provides excellent templating capabilities
- Focus should be on integration, not reimplementing existing functionality
- Simple templates are sufficient for the basic handler needs

Open Issues
===========

While the core specification is complete, several areas warrant further discussion:

### Documentation Quality Standards

- Should there be minimum documentation requirements for plugins?
- How should documentation quality be measured and enforced?
- What guidelines should be provided for effective plugin documentation?

### Integration with Package Managers

- Should documentation validation be integrated with PyPI package publishing?
- How should documentation versioning align with package versioning?
- What opportunities exist for documentation-based package discovery?

References
==========

- **OEP-3**: Entry Points-Based Plugin Discovery and Unified Component Naming
- **mkdocstrings Documentation**: https://mkdocstrings.github.io/
- **Python Packaging Guide**: https://packaging.python.org/en/latest/
- **Google Style Docstrings**: https://google.github.io/styleguide/pyguide.html

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
