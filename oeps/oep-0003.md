OEP: 3
Title: Entry Points-Based Plugin Discovery and Unified Component Naming
Author: Open World Agents Team
Status: Final
Type: Standards Track
Requires: 1, 2
Created: 07-Jun-2025
Post-History: 07-Jun-2025
Replaces: 2

Abstract
========

This OEP introduces a standardized plugin discovery mechanism using Python's Entry Points system and establishes unified naming conventions for all OWA components. Building upon the registry system defined in OEP-2, this specification eliminates the need for manual `activate_module()` calls by implementing automatic plugin discovery, introduces lazy loading for optimal performance, and unifies component naming to use a consistent `namespace/name` pattern across all component types.

Motivation
==========

The registry system established in OEP-2 provided a foundation for component management but had several limitations that hindered developer experience and system scalability:

1. **Manual Activation Required**: Developers had to explicitly call `activate_module()` for each plugin, creating friction and potential for errors
2. **Inconsistent Naming**: Callables used dot notation (`clock.time_ns`) while Listeners and Runnables used slash notation (`clock/tick`), creating confusion
3. **Non-Standard Discovery**: Custom module activation didn't follow Python packaging standards, limiting ecosystem integration
4. **Performance Issues**: All components were loaded at activation time, causing slow startup with many plugins
5. **Limited Discoverability**: No standard way for users to discover available plugins without manual documentation

These limitations became apparent as the OWA ecosystem grew and more third-party plugins were developed. A more robust, standards-compliant approach was needed to support a thriving plugin ecosystem.

Rationale
=========

The design is based on Python's official packaging standards and modern plugin architecture best practices:

**Python Standards Compliance**: Entry Points are the official Python mechanism for plugin discovery, as documented in the Python Packaging Guide. This ensures compatibility with standard Python tooling and packaging workflows.

**Zero-Configuration Usage**: Plugins work immediately after installation via `pip install`, eliminating the need for manual activation calls and reducing cognitive load for users.

**Unified Naming Convention**: All components now use the `namespace/name` pattern, providing consistency and eliminating the confusion between different notation systems.

**Lazy Loading Architecture**: Components are imported only when accessed, not when discovered, providing fast startup times and minimal memory usage even with many installed plugins.

**Enhanced Developer Experience**: Multiple access patterns (`CALLABLES["namespace/name"]` and `get_component("callables", "namespace", "name")`) provide flexibility while maintaining backward compatibility.

The design prioritizes developer experience, performance, and standards compliance while maintaining the flexibility and power of the existing registry system.

Specification
=============

## Entry Points-Based Plugin Declaration

### Plugin Package Structure

Plugins declare themselves using standard Python Entry Points in `pyproject.toml`:

```toml
[project]
name = "owa-env-example"
version = "0.1.0"
description = "Example environment plugin for Open World Agents"
dependencies = ["owa-core"]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project.entry-points."owa.env.plugins"]
example = "owa.env.plugins.example:plugin_spec"
```

### Plugin Specification

Each plugin must provide a `PluginSpec` object in a separate module to avoid circular imports during plugin discovery. The specification should be placed in `owa/env/plugins/<namespace>.py`:

```python
# File: owa/env/plugins/example.py
"""
Plugin specification for the Example environment plugin.

This module is kept separate to avoid circular imports during plugin discovery.
"""

from owa.core.plugin_spec import PluginSpec

plugin_spec = PluginSpec(
    namespace="example",
    version="0.1.0",
    description="Example environment plugin",
    author="Plugin Developer",
    components={
        "callables": {
            "add": "owa.env.example:add_numbers",
            "print": "owa.env.example:enhanced_print",
        },
        "listeners": {
            "events": "owa.env.example:EventListener",
        },
        "runnables": {
            "processor": "owa.env.example:DataProcessor",
        }
    }
)
```

**Important**: Do not create `__init__.py` files in the `plugins/` directory as this would interfere with namespace packaging.

### Plugin Module Structure Flexibility

**Zero Structure Limitations**: Custom environment plugins have complete freedom in their module organization. As long as the entry point is properly registered, the internal structure of your plugin module can be organized however you prefer.

**Required Structure**:
```
owa/env/plugins/
â””â”€â”€ myplugin.py              # Plugin specification (required)
owa/env/myplugin/
â””â”€â”€ __init__.py              # Your main module (required)
â””â”€â”€ [your code structure]    # Organize however you want!
```

**Example Valid Structures**:
```
# Minimal structure
owa/env/myplugin/
â”œâ”€â”€ __init__.py
â””â”€â”€ components.py

# Organized by component type
owa/env/myplugin/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ callables/
â”‚   â”œâ”€â”€ math.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ listeners/
â”‚   â””â”€â”€ events.py
â””â”€â”€ runnables/
    â””â”€â”€ processors.py

# Domain-driven structure
owa/env/myplugin/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ engine.py
â”‚   â””â”€â”€ config.py
â”œâ”€â”€ integrations/
â”‚   â”œâ”€â”€ api.py
â”‚   â””â”€â”€ database.py
â””â”€â”€ utils/
    â””â”€â”€ helpers.py

# Flat structure
owa/env/myplugin/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ feature_a.py
â”œâ”€â”€ feature_b.py
â””â”€â”€ shared_utils.py
```

The entry point system provides complete flexibility - organize your code in whatever way makes sense for your plugin's functionality and complexity.

## Unified Component Naming

### Naming Convention

All components now use the unified `namespace/name` pattern:

- **Callables**: `example/add`, `std/time_ns`, `desktop/click`
- **Listeners**: `example/events`, `std/tick`, `keyboard/press`  
- **Runnables**: `example/processor`, `std/monitor`, `desktop/recorder`

### Naming Rules

- **Namespace**: Must consist of letters, numbers, underscores, and hyphens: `^[a-zA-Z0-9_-]+$`
- **Name**: Should consist of letters, numbers, underscores, and dots: `^[a-zA-Z_][a-zA-Z0-9_.]*$`
- **Separator**: Always use forward slash (`/`) between namespace and name
- **Functional Grouping**: Use dots within names for logical grouping (e.g., `mouse.click`, `keyboard.type`)

## Automatic Plugin Discovery

### Discovery Process

The system automatically discovers plugins when `owa.core` is imported:

1. **Entry Point Scanning**: System scans all installed packages for entry points in the `"owa.env.plugins"` group
2. **Plugin Specification Loading**: For each entry point, load the specified `PluginSpec` object
3. **Component Registration**: Register component metadata (import paths) with appropriate registries
4. **Lazy Loading Setup**: Components remain unloaded until first access

### Zero-Configuration Usage

Users install plugins using standard pip and components are immediately available:

```bash
pip install owa-env-example
```

```python
from owa.core.registry import CALLABLES, LISTENERS, RUNNABLES

# Components automatically available - no activate_module() needed
result = CALLABLES["example/add"](5, 3)
listener = LISTENERS["example/events"]().configure(callback=my_callback)
processor = RUNNABLES["example/processor"]().configure(batch_size=100)
```

## Lazy Loading Architecture

### LazyImportRegistry

The `LazyImportRegistry` extends the base `Registry` class with lazy loading capabilities:

```python
from owa.core.registry import LazyImportRegistry, RegistryType

registry = LazyImportRegistry(RegistryType.CALLABLES)

# Registration modes
registry.register("example/add", obj_or_import_path="owa.env.example:add_function")
registry.register("example/multiply", obj_or_import_path=multiply_func, is_instance=True)
registry.register("example/divide", obj_or_import_path="owa.env.example:divide", eager_load=True)
```

### Loading Process

1. **Registration Phase**: Only metadata and import paths stored, no imports occur
2. **Access Phase**: Component imported when retrieved from registry (`CALLABLES["name"]`)
3. **Caching Phase**: Imported components cached for subsequent access
4. **Error Handling**: Import errors occur at access time, allowing graceful degradation

## Enhanced Component Access API

### Multiple Access Patterns

The system provides flexible component access methods:

```python
from owa.core import CALLABLES, get_component, list_components

# Pattern 1: Direct registry access
add_func = CALLABLES["example/add"]
result = add_func(5, 3)

# Pattern 2: Function-based access with parameters
add_func = get_component("callables", namespace="example", name="add")
result = add_func(5, 3)

# Pattern 3: Namespace-based access
example_callables = get_component("callables", namespace="example")
# Returns: {"add": <function>, "print": <function>}

# Pattern 4: Component discovery
all_callables = list_components("callables")
example_only = list_components("callables", namespace="example")
```

### API Functions

```python
def get_component(component_type: str, namespace: str = None, name: str = None) -> Any:
    """Flexible component access with multiple patterns."""

def list_components(component_type: str = None, namespace: str = None) -> Dict[str, List[str]]:
    """List available components with optional filtering."""

def get_registry(component_type: str) -> Registry:
    """Get the appropriate registry for component type."""
```

Evolution from OEP-2
====================

## Key Changes from Registry System

### Before (OEP-2 System)
```python
from owa.core.registry import CALLABLES, LISTENERS, activate_module

activate_module("owa.env.std")
activate_module("owa.env.example")

time_func = CALLABLES["clock.time_ns"]  # dot notation
listener = LISTENERS["example/events"]  # slash notation
```

### After (Entry Points System)
```python
from owa.core.registry import CALLABLES, LISTENERS
# No activate_module needed!

time_func = CALLABLES["std/time_ns"]    # unified slash notation
listener = LISTENERS["example/events"]  # same slash notation

# Enhanced access also available
time_func = get_component("callables", namespace="std", name="time_ns")
```

## Migration Path

### Plugin Developer Migration

1. **Add Entry Point Declaration**: Add entry point to `pyproject.toml` pointing to `owa.env.plugins.<namespace>:plugin_spec`
2. **Create Plugin Specification**: Define `PluginSpec` in separate `owa/env/plugins/<namespace>.py` file
3. **Update Component Names**: Change to unified `namespace/name` pattern
4. **Remove Decorator Registration**: Replace `@CALLABLES.register()` with specification-based registration

### User Migration

1. **Remove Activation Calls**: Delete `activate_module()` calls from user code
2. **Update Component Names**: Change dot notation to slash notation for callables
3. **Install via pip**: Ensure plugins are properly installed rather than manually imported

Backwards Compatibility
=======================

This OEP introduces breaking changes to the component naming system and plugin activation mechanism:

**Breaking Changes:**
1. **Naming Convention**: Callables must migrate from dot notation to slash notation
2. **Activation Method**: `activate_module()` calls are no longer needed and should be removed
3. **Registration Method**: Decorator-based registration replaced with specification-based registration

**Migration Support:**
- Comprehensive migration guide provided in documentation
- Example implementations demonstrate new patterns
- Gradual migration path allows incremental adoption

**Compatibility Timeline:**
- OEP-2 style plugins continue to work during transition period
- Full migration required for optimal performance and feature access
- Legacy support may be removed in future major versions

Security Implications
=====================

The Entry Points system introduces new security considerations:

**Reduced Attack Surface:**
- Eliminates arbitrary module execution via `activate_module()`
- Components loaded only when accessed, limiting exposure
- Specification-based registration provides better validation opportunities

**New Considerations:**
- Entry Points can still reference malicious code
- Lazy loading defers but doesn't eliminate code execution risks
- Plugin specifications should be validated before registration

**Mitigation Strategies:**
- Validate plugin specifications during discovery
- Implement component access logging for security monitoring
- Consider sandboxing for untrusted plugins
- Provide tools for plugin verification and auditing

How to Teach This
=================

The Entry Points system can be taught through progressive examples:

### 1. Basic Usage (Consumer Perspective)
```python
# Install and use - no configuration needed
pip install owa-env-example
from owa.core import CALLABLES
result = CALLABLES["example/add"](5, 3)
```

### 2. Component Discovery
```python
from owa.core import list_components, get_component
print(list_components("callables"))  # See what's available
add_func = get_component("callables", "example", "add")
```

### 3. Plugin Development
```python
# File: owa/env/plugins/myplugin.py
"""Plugin specification for MyPlugin environment plugin."""

from owa.core.plugin_spec import PluginSpec

plugin_spec = PluginSpec(
    namespace="myplugin",
    components={"callables": {"hello": "owa.env.myplugin:say_hello"}}
)
```

```toml
# pyproject.toml entry point
[project.entry-points."owa.env.plugins"]
myplugin = "owa.env.plugins.myplugin:plugin_spec"
```

### 4. Advanced Patterns
- Multiple access methods
- Lazy loading behavior
- Error handling strategies
- Performance considerations

**Key Teaching Points:**
- **Standards Compliance**: Emphasize that this follows Python packaging standards
- **Zero Configuration**: Highlight the elimination of manual activation
- **Performance Benefits**: Explain lazy loading advantages
- **Unified Experience**: Show consistency across component types

## Enhanced CLI Tools

The `owl env` command-line interface provides comprehensive plugin and component management with enhanced filtering, search, and analysis capabilities:

### Core Commands

```bash
# Plugin discovery and listing (automatic - no activation needed)
$ owl env list                                    # List all discovered plugins
$ owl env list --namespace example                # Filter by namespace
$ owl env list --type callables                   # Filter by component type
$ owl env list --search mouse                     # Search by pattern
$ owl env list --details                          # Show import paths and load status
$ owl env list --table                            # Display in table format

# Plugin information with enhanced options
$ owl env show example                             # Show plugin information
$ owl env show example --components               # Show detailed component list
$ owl env show example --inspect mouse.click      # Inspect specific component
$ owl env show example --type callables           # Filter by component type
$ owl env show example --search window            # Search within namespace

# Plugin validation (for development)
$ owl env validate owa.env.plugins.example:plugin_spec  # Validate Python entry point
$ owl env validate ./plugin.yaml                        # Validate YAML plugin specification
```

### Enhanced Discovery and Analysis

```bash
# Advanced search capabilities
$ owl env search "mouse.*click"                   # Regex pattern search
$ owl env search window --details --table         # Detailed search results
$ owl env search keyboard --type callables        # Search specific component type

# Ecosystem analysis and statistics
$ owl env stats                                    # Show ecosystem statistics
$ owl env stats --by-namespace                    # Group by namespace
$ owl env stats --by-type                         # Group by component type
$ owl env health                                   # Perform health check

# Quick access shortcuts
$ owl env ls                                       # Quick plugin list
$ owl env ls desktop                              # Quick namespace exploration
$ owl env find mouse                              # Quick component search
$ owl env namespaces                              # List all available namespaces
```

### CLI Output Examples (Real Implementation)

```bash
$ owl env list
ğŸ“¦ Discovered Plugins (4)
â”œâ”€â”€ desktop (25 components)
â”‚   â”œâ”€â”€ ğŸ“ Callables: 20
â”‚   â””â”€â”€ ğŸ‘‚ Listeners: 5
â”œâ”€â”€ example (7 components)
â”‚   â”œâ”€â”€ ğŸ“ Callables: 3
â”‚   â”œâ”€â”€ ğŸ‘‚ Listeners: 2
â”‚   â””â”€â”€ ğŸƒ Runnables: 2
â”œâ”€â”€ gst (4 components)
â”‚   â”œâ”€â”€ ğŸ‘‚ Listeners: 2
â”‚   â””â”€â”€ ğŸƒ Runnables: 2
â””â”€â”€ std (2 components)
    â”œâ”€â”€ ğŸ“ Callables: 1
    â””â”€â”€ ğŸ‘‚ Listeners: 1

$ owl env list --details
ğŸ“¦ Discovered Plugins (4)
â”œâ”€â”€ desktop (25 components)
â”‚   â”œâ”€â”€ ğŸ“ Callables: 20
â”‚   â”œâ”€â”€ ğŸ‘‚ Listeners: 5
â”‚   â”œâ”€â”€ ğŸ”§ Callables Details
â”‚   â”‚   â”œâ”€â”€ desktop/mouse.click [â³ lazy] (owa.env.desktop.keyboard_mouse.callables:click)
â”‚   â”‚   â”œâ”€â”€ desktop/keyboard.type [â³ lazy] (owa.env.desktop.keyboard_mouse.callables:keyboard_type)
â”‚   â”‚   â””â”€â”€ desktop/window.get_active_window [â³ lazy] (owa.env.desktop.window.callables:get_active_window)
â”‚   â””â”€â”€ ğŸ”§ Listeners Details
â”‚       â”œâ”€â”€ desktop/keyboard [â³ lazy] (owa.env.desktop.keyboard_mouse.listeners:KeyboardListenerWrapper)
â”‚       â””â”€â”€ desktop/mouse [â³ lazy] (owa.env.desktop.keyboard_mouse.listeners:MouseListenerWrapper)

$ owl env show example --components
ğŸ“¦ Plugin: example (7 components)
â”œâ”€â”€ ğŸ“ Callables: 3
â”œâ”€â”€ ğŸ‘‚ Listeners: 2
â””â”€â”€ ğŸƒ Runnables: 2
ğŸ“ Callables (3)
â”œâ”€â”€ example/add
â”œâ”€â”€ example/callable
â””â”€â”€ example/print
ğŸ‘‚ Listeners (2)
â”œâ”€â”€ example/listener
â””â”€â”€ example/timer
ğŸƒ Runnables (2)
â”œâ”€â”€ example/counter
â””â”€â”€ example/runnable

$ owl env search "mouse" --table
               Search Results for 'mouse' (9 matches)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”ƒ Component               â”ƒ Type      â”ƒ Namespace â”ƒ Name            â”ƒ
â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”©
â”‚ desktop/mouse           â”‚ listeners â”‚ desktop   â”‚ mouse           â”‚
â”‚ desktop/mouse.click     â”‚ callables â”‚ desktop   â”‚ mouse.click     â”‚
â”‚ desktop/mouse.move      â”‚ callables â”‚ desktop   â”‚ mouse.move      â”‚
â”‚ desktop/mouse.press     â”‚ callables â”‚ desktop   â”‚ mouse.press     â”‚
â”‚ desktop/mouse.scroll    â”‚ callables â”‚ desktop   â”‚ mouse.scroll    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

$ owl env stats
ğŸ“Š Plugin Ecosystem Statistics
â”œâ”€â”€ ğŸ“ˆ Overview
â”‚   â”œâ”€â”€ Total Components: 38
â”‚   â”œâ”€â”€ âœ… Loaded: 0
â”‚   â”œâ”€â”€ â³ Lazy: 38
â”‚   â””â”€â”€ ğŸ“¦ Namespaces: 4
â”œâ”€â”€ ğŸ”§ By Component Type
â”‚   â”œâ”€â”€ ğŸ“ Callables: 24 (63.2%)
â”‚   â”œâ”€â”€ ğŸ‘‚ Listeners: 10 (26.3%)
â”‚   â””â”€â”€ ğŸƒ Runnables: 4 (10.5%)
â””â”€â”€ ğŸ“¦ Top Namespaces
    â”œâ”€â”€ desktop: 25 (65.8%)
    â”œâ”€â”€ example: 7 (18.4%)
    â”œâ”€â”€ gst: 4 (10.5%)
    â””â”€â”€ std: 2 (5.3%)
```

Reference Implementation
========================

The reference implementation is available in `owa-core`:

**Core Components:**
- `owa.core.registry.LazyImportRegistry` - Lazy loading registry implementation
- `owa.core.plugin_spec.PluginSpec` - Plugin specification with validation
- `owa.core.discovery` - Entry points-based plugin discovery
- `owa.core.api` - Enhanced component access functions

**Example Implementations:**
- `owa-env-example` - Complete example plugin demonstrating all patterns with refactored structure
- `owa-env-desktop` - Desktop environment plugin with comprehensive component set
- `owa-env-gst` - GStreamer plugin demonstrating multimedia capabilities
- `owa.env.std` - Standard library components migrated to new system
- Migration examples in documentation

**Testing:**
- Comprehensive test suite covering lazy loading, discovery, and access patterns
- Performance benchmarks demonstrating startup time improvements
- Integration tests with multiple plugin scenarios

The implementation has been validated with real-world plugins and demonstrates significant improvements in startup performance and developer experience.

Rejected Ideas
==============

### Configuration File-Based Discovery

Using configuration files (JSON/YAML) for plugin discovery was considered but rejected because:
- Entry Points are the Python standard for plugin discovery
- Configuration files require additional parsing and validation
- Entry Points integrate better with packaging tools
- Metadata is already available through package management

### Backward Compatible Naming

Maintaining both dot and slash notation was considered but rejected because:
- It would perpetuate confusion between component types
- Implementation complexity would increase significantly
- Clear migration path is preferable to indefinite dual support
- Unified naming provides better long-term developer experience

### Immediate Loading Option

Providing an option to disable lazy loading was considered but rejected because:
- Lazy loading provides significant performance benefits
- Edge cases requiring immediate loading can be handled through eager_load parameter
- Complexity of dual loading modes outweighs benefits
- Lazy loading is becoming standard practice in modern frameworks

### Centralized Plugin Registry

A centralized online registry for plugins was discussed but deemed outside scope because:
- Entry Points already provide decentralized discovery
- Centralized registries introduce single points of failure
- Package managers (PyPI) already serve this function
- Focus should remain on technical implementation rather than ecosystem management

Open Issues
===========

At the time of this OEP's finalization, the core system is implemented and functional. Future enhancements may include:

1. **Enhanced Type Safety**: Better IDE support and type checking for component access
2. **Plugin Validation Tools**: Automated validation and testing tools for plugin developers
3. **Performance Monitoring**: Tools for monitoring lazy loading performance and optimization
4. **Migration Tooling**: Automated tools for migrating OEP-2 style plugins

These enhancements would be addressed in future OEPs as the ecosystem matures and requirements become clearer.

References
==========

- OEP-1: Core Component Design of OWA's Env - Callable, Listener, and Runnable
- OEP-2: Registry Pattern and Module System for OWA's Env
- Python Packaging Guide: https://packaging.python.org/en/latest/guides/creating-and-discovering-plugins/
- Entry Points Specification: https://packaging.python.org/en/latest/specifications/entry-points/
- Implementation: `projects/owa-core/owa/core/`
- Example Plugin: `projects/owa-env-example/`
- Migration Guide: `docs/migration/oep-3.md`

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.
