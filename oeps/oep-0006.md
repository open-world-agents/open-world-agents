OEP: 6
Title: Dedicated OWA Message Package and OWAMcap Profile Specification
Author: Open World Agents Team
Status: Implemented
Type: Standards Track
Replaces: 5
Created: 10-Jun-2025
Post-History: 10-Jun-2025, 14-Jun-2025
Implementation: Complete

Abstract
========

This OEP proposes the creation of a dedicated `owa-msgs` package to manage OWA message definitions separately from the EnvPlugin system. The proposal establishes OWAMcap as a formal specification for MCAP files with the `owa` profile and standardized OWA message definitions. This approach provides better separation of concerns, improved package management, and enables custom message registration through entry points in pyproject.toml files.

Motivation
==========

The current approach of embedding message definitions within individual EnvPlugins creates several architectural and practical problems:

1. **Tight Coupling**: Message schemas are unnecessarily coupled with runtime plugin components, making it difficult to use messages independently of plugin functionality.

2. **Package Management Complexity**: Users who only need message definitions for data processing must install entire plugin packages with their runtime dependencies, creating unnecessary bloat.

3. **Discovery Overhead**: Dynamic message discovery from multiple plugin packages adds runtime complexity and performance overhead to the mcap-owa-support package.

4. **Namespace Confusion**: Plugin namespaces become overloaded with both component and message concerns, reducing clarity and making the system harder to understand.

5. **Schema Evolution Challenges**: Managing message schema evolution across multiple plugin packages is complex and error-prone.

6. **Deployment Fragmentation**: Message definitions scattered across multiple packages make it difficult to ensure consistent message schemas across different environments.

A dedicated message package addresses these issues by providing a centralized, well-managed location for OWA message definitions while maintaining extensibility through standardized entry points.

Rationale
=========

The design separates message definitions from runtime components while maintaining extensibility:

**Separation of Concerns**: Message schemas are data contracts that should be independent of runtime implementation details. A dedicated package provides clear boundaries.

**Simplified Package Management**: Users can install only the message definitions they need without pulling in unnecessary runtime dependencies.

**Centralized Schema Management**: A single package provides better control over message schema evolution, versioning, and compatibility.

**Performance Optimization**: Static message registration through entry points eliminates runtime discovery overhead.

**Clear Extensibility Model**: The entry point system provides a standardized way for third-party packages to register custom message types.

**Better Documentation**: Centralized message definitions enable comprehensive documentation and schema browsing tools.

Specification
=============

## OWA Messages Package

### Package Structure

The `owa-msgs` package provides the core message definitions for the OWA ecosystem:

```
owa-msgs/
├── pyproject.toml
└── owa/
    └── msgs/
        └── desktop/
            ├── keyboard.py
            ├── mouse.py
            ├── screen.py
            └── window.py
```

**Note**: The `owa.msgs` namespace uses implicit namespace packaging (PEP 420) and deliberately omits `__init__.py` files. This allows multiple packages to contribute to the same namespace without conflicts, enabling third-party packages to extend the `owa.msgs` namespace with their own message definitions.

The package contains only concrete message definitions organized by domain. Base classes (`BaseMessage`, `OWAMessage`) remain in `owa.core.message` to avoid circular dependencies and maintain clear separation between the core framework and message definitions.

### Core Message Definitions

Standard OWA message types are organized by domain:

```python
# owa/msgs/desktop/keyboard.py
from owa.core.message import OWAMessage

class KeyboardEvent(OWAMessage):
    _type = "desktop/KeyboardEvent"
    event_type: str  # "press", "release"
    vk: int
    timestamp: int

class KeyboardState(OWAMessage):
    _type = "desktop/KeyboardState"
    buttons: list[int]
    timestamp: int
```

### Entry Point Registration

The package registers message types through entry points:

```toml
# pyproject.toml
[project.entry-points."owa.msgs"]
"desktop/KeyboardEvent" = "owa.msgs.desktop.keyboard:KeyboardEvent"
"desktop/KeyboardState" = "owa.msgs.desktop.keyboard:KeyboardState"
"desktop/MouseEvent" = "owa.msgs.desktop.mouse:MouseEvent"
"desktop/MouseState" = "owa.msgs.desktop.mouse:MouseState"
"desktop/ScreenEmitted" = "owa.msgs.desktop.screen:ScreenEmitted"
"desktop/WindowInfo" = "owa.msgs.desktop.window:WindowInfo"
```

## OWAMcap Profile Specification

### Formal Definition

OWAMcap is defined as:
- **Base Format**: Standard MCAP container format
- **Profile**: `owa` designation in MCAP metadata
- **Schema Encoding**: JSON Schema
- **Message Interface**: All messages must implement `BaseMessage` from `owa.core.message`
- **Standard Messages**: Core message types from `owa-msgs` package

### Profile Metadata

OWAMcap files must include the following metadata:

```python
# MCAP profile metadata
profile = "owa"
library = f"mcap-owa-support {version}; mcap {mcap_version}"
```

### Automatic Message Discovery

The `owa.core` package provides automatic message discovery through entry points:

```python
# owa/core/messages.py
import pkg_resources
from typing import Dict, Type
from .message import BaseMessage

class MessageRegistry:
    """Registry for automatic message discovery via entry points."""

    def __init__(self):
        self._messages: Dict[str, Type[BaseMessage]] = {}
        self._loaded = False

    def _load_messages(self):
        """Load all registered message types from entry points."""
        if self._loaded:
            return

        for entry_point in pkg_resources.iter_entry_points("owa.msgs"):
            try:
                message_class = entry_point.load()
                self._messages[entry_point.name] = message_class
            except Exception as e:
                # Log warning but continue loading other messages
                print(f"Warning: Failed to load message {entry_point.name}: {e}")

        self._loaded = True

    def get(self, message_type: str) -> Type[BaseMessage]:
        """Get message class by type name."""
        self._load_messages()
        if message_type not in self._messages:
            raise ValueError(f"Unknown message type: {message_type}")
        return self._messages[message_type]

    def __getitem__(self, message_type: str) -> Type[BaseMessage]:
        """Allow dictionary-style access."""
        return self.get(message_type)

    def __contains__(self, message_type: str) -> bool:
        """Check if message type is registered."""
        self._load_messages()
        return message_type in self._messages

    def keys(self):
        """Get all registered message type names."""
        self._load_messages()
        return self._messages.keys()

    def values(self):
        """Get all registered message classes."""
        self._load_messages()
        return self._messages.values()

    def items(self):
        """Get all (name, class) pairs."""
        self._load_messages()
        return self._messages.items()

# Global message registry instance
MESSAGES = MessageRegistry()
```

### Usage Examples

```python
# Import the global message registry
from owa.core import MESSAGES

# Access message classes directly
KeyboardEvent = MESSAGES['desktop/KeyboardEvent']
MouseEvent = MESSAGES['desktop/MouseEvent']

# Check if a message type exists
if 'desktop/KeyboardEvent' in MESSAGES:
    print("KeyboardEvent is available")

# List all available message types
for message_type in MESSAGES.keys():
    print(f"Available: {message_type}")

# Create message instances
event = MESSAGES['desktop/KeyboardEvent'](
    event_type="press",
    vk=65,
    timestamp=1234567890
)
```

## Custom Message Registration

### Third-Party Package Integration

External packages can register custom message types:

```toml
# third-party-package/pyproject.toml
[project.entry-points."owa.msgs"]
"sensors/TemperatureReading" = "custom_sensors.messages:TemperatureReading"
"sensors/HumidityReading" = "custom_sensors.messages:HumidityReading"
```

### Message Type Naming Convention

- **Format**: `domain/MessageType`
- **Domain**: Logical grouping (e.g., `desktop`, `sensors`, `system`)
- **MessageType**: PascalCase message name
- **Examples**: `desktop/KeyboardEvent`, `desktop/WindowInfo`, `sensors/TemperatureReading`

**Note**: The simplified naming convention removes package prefixes to avoid redundancy and improve readability. All core OWA messages use domain-based naming, and third-party packages should follow the same pattern.

## Integration with mcap-owa-support

### Enhanced Message Discovery

The mcap-owa-support package integrates with the `owa.core.MESSAGES` registry:

```python
from mcap_owa.highlevel import OWAMcapWriter
from owa.core import MESSAGES

# Messages are automatically discovered and available
with OWAMcapWriter("events.mcap") as writer:
    # Create message using the global registry
    KeyboardEvent = MESSAGES['desktop/KeyboardEvent']
    event = KeyboardEvent(event_type="press", vk=65, timestamp=1234567890)
    writer.write_message("keyboard", event)
```

### Automatic Schema Registration

Message schemas are automatically available in OWAMcap operations:

```python
from mcap_owa.highlevel import OWAMcapWriter, OWAMcapReader
from owa.core import MESSAGES

# Writing with automatic message discovery
with OWAMcapWriter("events.mcap") as writer:
    for message_type in ['desktop/KeyboardEvent', 'desktop/MouseEvent']:
        if message_type in MESSAGES:
            print(f"Message type {message_type} is available")

# Reading with automatic message resolution
with OWAMcapReader("events.mcap") as reader:
    for msg in reader.iter_decoded_messages():
        # Message types are automatically resolved from the registry
        print(f"Received {msg.schema_name}: {msg.decoded_message}")
```

### Backward Compatibility

Existing import patterns continue to work alongside the new registry:

```python
# Traditional import (still supported)
from owa.msgs.desktop.keyboard import KeyboardEvent

# New registry access (recommended)
from owa.core import MESSAGES
KeyboardEvent = MESSAGES['desktop/KeyboardEvent']

# Both create the same class
assert KeyboardEvent is MESSAGES['desktop/KeyboardEvent']
```

Backwards Compatibility
=======================

This OEP maintains full backward compatibility:

**No Breaking Changes:**
- Existing OWAMcap files remain fully compatible
- Current mcap-owa-support APIs continue to work unchanged
- Existing message classes continue to function

**Migration Path:**
- Core OWA message types are moved to `owa-msgs` package
- Existing imports are maintained through compatibility shims
- Gradual migration timeline allows smooth transition

**Additive Changes:**
- New entry point-based message discovery (optional)
- Enhanced CLI tools for message browsing
- Improved documentation and schema tools

Implementation Requirements
===========================

## Core Components

1. **owa-msgs Package**: Create dedicated package with core message definitions
2. **Entry Point System**: Implement message registration through entry points
3. **MESSAGES Registry**: Add automatic message discovery to `owa.core` with global `MESSAGES` registry
4. **Registry Integration**: Update mcap-owa-support to use the `owa.core.MESSAGES` registry
5. **CLI Tools**: Add commands for message browsing and validation
6. **Documentation**: Comprehensive message schema documentation

## Migration Strategy

1. **Phase 1**: Create owa-msgs package with core message types
2. **Phase 2**: Add entry point discovery to mcap-owa-support
3. **Phase 3**: Add compatibility shims for existing imports
4. **Phase 4**: Update documentation and examples
5. **Phase 5**: Deprecate old message locations (future OEP)

## Validation Requirements

- Message type uniqueness across all registered packages
- Proper BaseMessage interface implementation
- Entry point registration validation
- Schema compatibility checking

Security Implications
=====================

The entry point system introduces minimal security considerations:

- Entry points are resolved at import time, not runtime
- Message classes must still implement the BaseMessage interface
- No arbitrary code execution beyond normal Python import mechanisms
- Package installation follows standard Python security practices

How to Teach This
=================

The new system simplifies the mental model for users:

1. **Message Access**: Import `MESSAGES` from `owa.core` for automatic message discovery
2. **Message Definitions**: Install `owa-msgs` for core message types
3. **Custom Messages**: Create packages with entry point registration
4. **Usage**: Access messages via `MESSAGES['domain/MessageType']` or traditional imports
5. **Discovery**: Use CLI tools to browse available message types

**Teaching Examples:**

```python
# Simple message access
from owa.core import MESSAGES
KeyboardEvent = MESSAGES['desktop/KeyboardEvent']

# Check what's available
print(list(MESSAGES.keys()))

# Use in OWAMcap
from mcap_owa.highlevel import OWAMcapWriter
with OWAMcapWriter("data.mcap") as writer:
    event = MESSAGES['desktop/KeyboardEvent'](...)
    writer.write_message("keyboard", event)
```

This approach aligns with familiar Python packaging patterns and provides both convenience and discoverability.

Reference Implementation
========================

**Status: COMPLETE** - All phases have been implemented and tested.

## Implemented Components

### Phase 1: Core Registry Implementation ✅
- **`owa.core.messages.py`**: Complete `MessageRegistry` class with entry point discovery using modern `importlib.metadata`
- **`owa.core.__init__.py`**: Global `MESSAGES` registry exported and available
- **Message validation**: Enhanced `verify_type()` method supports both old and new message formats
- **Comprehensive tests**: Full test coverage for message registry functionality

### Phase 2: owa-msgs Package ✅
- **Package structure**: Complete `projects/owa-msgs/` with namespace packaging (PEP 420)
- **Core message types**: Desktop domain messages implemented:
  - `desktop/KeyboardEvent` and `desktop/KeyboardState`
  - `desktop/MouseEvent` and `desktop/MouseState`
- **Entry point registration**: Configured in `pyproject.toml` for automatic discovery
- **Package documentation**: README with usage examples and API documentation
- **Message tests**: Full test coverage for all message types

### Phase 3: mcap-owa-support Integration ✅
- **Enhanced decoder**: Updated to use `owa.core.MESSAGES` registry for domain-based messages
- **Backward compatibility**: Supports both old module-based and new domain-based message names
- **Graceful fallback**: Dictionary decoding when message classes are not available
- **Improved error handling**: Better warnings and error messages for unsupported formats

### Phase 4: CLI and Tooling ✅
- **`owl messages list`**: Browse available message types with filtering and multiple output formats
- **`owl messages show`**: Detailed message information including schema and usage examples
- **`owl messages validate`**: Comprehensive validation of message registry and definitions
- **Rich output**: Beautiful terminal output with tables, syntax highlighting, and progress indicators

### Phase 5: Migration and Compatibility ✅
- **Legacy compatibility**: Backward-compatible imports in `owa.env.desktop.msg` with deprecation warnings
- **OWAMcap conversion**: `owl mcap convert-legacy` command for converting old MCAP files to new format
- **Gradual migration**: Existing code continues to work with deprecation warnings guiding users to new APIs

### Phase 6: Documentation Updates ✅
- **OEP-0006 status**: Updated to "Implemented" with complete implementation details
- **Usage examples**: Working demonstration script showing all features
- **Integration tests**: Comprehensive testing of real-world usage scenarios

## Implementation Files

```
projects/owa-core/owa/core/
├── messages.py              # MessageRegistry implementation
└── __init__.py              # Export MESSAGES registry

projects/owa-msgs/
├── pyproject.toml           # Entry point registrations
├── owa/msgs/desktop/
│   ├── keyboard.py          # KeyboardEvent, KeyboardState
│   └── mouse.py             # MouseEvent, MouseState
└── tests/                   # Comprehensive test suite

projects/mcap-owa-support/mcap_owa/
└── decoder.py               # Enhanced decoder with registry support

projects/owa-cli/owa/cli/
├── messages/                # Message management commands
│   ├── list.py              # List available messages
│   ├── show.py              # Show message details
│   └── validate.py          # Validate message registry
└── mcap/convert_legacy.py   # Legacy MCAP conversion

projects/owa-env-desktop/owa/env/desktop/
└── msg.py                   # Backward compatibility layer

examples/
└── oep_0006_demo.py         # Complete working demonstration
```

## Validation Results

All implementation phases have been validated with:
- **Unit tests**: 33+ tests covering all components
- **Integration tests**: Real entry point discovery and message usage
- **CLI functionality**: All commands working with rich output
- **Backward compatibility**: Legacy imports work with deprecation warnings
- **Performance**: Lazy loading and efficient message discovery
- **Documentation**: Complete examples and usage guides

The implementation fully satisfies all requirements specified in this OEP and is ready for production use.

Rejected Ideas
==============

**Plugin-Based Message Registration (OEP-5)**: Rejected due to tight coupling between message schemas and runtime components. This approach created unnecessary complexity and deployment overhead.

**Monolithic Message Module**: Considered embedding all message types in owa-core, but rejected because it would prevent third-party message type registration and create a large, unwieldy module.

**Runtime Message Discovery**: Considered dynamic message discovery at runtime, but rejected due to performance overhead and complexity. Entry points provide the same flexibility with better performance.

**Namespace-Free Message Types**: Considered using simple message names without package prefixes, but rejected due to collision risks and lack of clear ownership.

Open Issues
===========

1. **Message Versioning**: How should message schema evolution be handled across package versions?
2. **Dependency Management**: Should owa-msgs have minimal dependencies or include validation libraries?
3. **Schema Validation**: What level of runtime schema validation should be enforced?
4. **Package Naming**: Should the package be `owa-msgs`, `owa-messages`, or follow a different convention?
5. **Migration Timeline**: What is the appropriate timeline for deprecating old message locations?

References
==========

- MCAP Format Specification: https://mcap.dev/
- Python Entry Points: https://packaging.python.org/specifications/entry-points/
- OWAMcap Format Documentation: docs/data/data_format_v2.md
- BaseMessage Interface: projects/owa-core/owa/core/message.py
- OEP-5: Message Definition Registration in EnvPlugin System (Rejected)

Implementation Summary
=====================

OEP-0006 has been successfully implemented and deployed. The implementation provides:

**Core Benefits Achieved:**
- ✅ Centralized message definitions in dedicated `owa-msgs` package
- ✅ Automatic message discovery via Python entry points
- ✅ Domain-based naming convention (`desktop/KeyboardEvent`)
- ✅ Backward compatibility with existing code
- ✅ Enhanced CLI tooling for message management
- ✅ Seamless OWAMcap integration with improved decoder
- ✅ Migration tools for legacy MCAP files

**Usage Examples:**

```python
# New recommended usage
from owa.core import MESSAGES
KeyboardEvent = MESSAGES['desktop/KeyboardEvent']
event = KeyboardEvent(event_type="press", vk=65)

# CLI commands
$ owl messages list --domain desktop
$ owl messages show desktop/KeyboardEvent --example
$ owl messages validate
$ owl mcap convert-legacy old_file.mcap -o new_file.mcap
```

**Migration Path:**
1. Install `owa-msgs` package: `pip install owa-msgs`
2. Update imports to use new format (optional - old imports still work)
3. Use CLI tools to validate and convert existing MCAP files
4. Leverage message registry for dynamic message access

The implementation maintains full backward compatibility while providing a modern, extensible foundation for the OWA message ecosystem.

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
